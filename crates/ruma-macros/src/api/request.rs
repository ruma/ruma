use std::collections::BTreeMap;

use cfg_if::cfg_if;
use proc_macro2::TokenStream;
use quote::quote;

use super::ensure_feature_presence;
use crate::util::{PrivateField, StructFieldExt, expand_fields_as_list, import_ruma_common};

mod incoming;
mod outgoing;
mod parse;

pub(crate) use self::parse::RequestAttrs;

/// Expand the `#[request]` macro on a struct.
///
/// This uses the `#[derive(Request)]` macro internally.
pub fn expand_request(attrs: RequestAttrs, item: syn::ItemStruct) -> TokenStream {
    let ruma_common = import_ruma_common();
    let ruma_macros = quote! { #ruma_common::exports::ruma_macros };

    let maybe_feature_error = ensure_feature_presence().map(syn::Error::to_compile_error);

    let error_ty = attrs.error_ty_or_default(&ruma_common);

    cfg_if! {
        // Make the macro expand the internal derives, such that Rust Analyzer's expand macro helper can
        // render their output. Requires a nightly toolchain.
        if #[cfg(feature = "__internal_macro_expand")] {
            use syn::parse_quote;

            let mut derive_input = item.clone();
            derive_input.attrs.push(parse_quote! { #[ruma_api(error = #error_ty)] });
            crate::util::cfg_expand_struct(&mut derive_input);

            let extra_derive = quote! { #ruma_macros::_FakeDeriveRumaApi };
            let ruma_api_attribute = quote! {};
            let request_impls =
                expand_derive_request(derive_input).unwrap_or_else(syn::Error::into_compile_error);
        } else {
            let extra_derive = quote! { #ruma_macros::Request };
            let ruma_api_attribute = quote! { #[ruma_api(error = #error_ty)] };
            let request_impls = quote! {};
        }
    }

    quote! {
        #maybe_feature_error

        #[derive(Clone, Debug, #ruma_common::serde::_FakeDeriveSerde, #extra_derive)]
        #[cfg_attr(not(ruma_unstable_exhaustive_types), non_exhaustive)]
        #ruma_api_attribute
        #item

        #request_impls
    }
}

/// Expand the `#[derive(Request)]` macro.
pub fn expand_derive_request(input: syn::ItemStruct) -> syn::Result<TokenStream> {
    let request = Request::try_from(input)?;

    let ruma_common = import_ruma_common();
    let impls = request.expand_impls(&ruma_common);
    let tests = request.expand_tests(&ruma_common);

    Ok(quote! {
        #impls

        #[allow(deprecated)]
        #[cfg(test)]
        mod __request {
            #tests
        }
    })
}

/// A parsed struct representing an API request.
struct Request {
    /// The name of the struct.
    ident: syn::Ident,

    /// The generics of the struct.
    generics: syn::Generics,

    /// The HTTP headers.
    headers: RequestHeaders,

    /// The path variables.
    path: RequestPath,

    /// The query variables.
    query: RequestQuery,

    /// The body.
    body: RequestBody,

    /// The type used for the `EndpointError` associated type on `OutgoingRequest` and
    /// `IncomingRequest` implementations.
    error_ty: syn::Type,
}

impl Request {
    /// Expand the implementations generated by this macro.
    fn expand_impls(&self, ruma_common: &TokenStream) -> TokenStream {
        let ruma_macros = quote! { #ruma_common::exports::ruma_macros };
        let serde = quote! { #ruma_common::exports::serde };

        let request_body_serde_struct =
            self.body.expand_serde_struct_definition(&ruma_macros, &serde);
        let request_query_serde_struct =
            self.query.expand_serde_struct_definition(&ruma_macros, &serde);

        let outgoing_request_impl = self.expand_outgoing(ruma_common);
        let incoming_request_impl = self.expand_incoming(ruma_common);

        quote! {
            #request_body_serde_struct
            #request_query_serde_struct

            #[allow(deprecated)]
            mod __request_impls {
                use super::*;
                #outgoing_request_impl
                #incoming_request_impl
            }
        }
    }

    /// Expand the tests generated by this macro.
    fn expand_tests(&self, ruma_common: &TokenStream) -> TokenStream {
        let ident = &self.ident;

        let mut tests = self.path.expand_tests(ident, ruma_common);
        tests.extend(self.body.expand_tests(ident, ruma_common));

        tests
    }
}

/// Parsed HTTP headers of a request struct.
#[derive(Default)]
pub struct RequestHeaders(BTreeMap<syn::Ident, syn::Field>);

impl RequestHeaders {
    /// Generate code for a comma-separated list of field names.
    ///
    /// Only the `#[cfg]` attributes on the fields are forwarded.
    fn expand_fields(&self) -> TokenStream {
        expand_fields_as_list(self.0.values())
    }
}

/// Request path fields.
#[derive(Default)]
pub struct RequestPath(Vec<syn::Field>);

impl RequestPath {
    /// Generate code to test the path parameters for the request with the given ident.
    fn expand_tests(&self, ident: &syn::Ident, ruma_common: &TokenStream) -> TokenStream {
        let path_fields = self.0.iter().map(|f| f.ident().to_string());

        quote! {
            #[::std::prelude::v1::test]
            fn path_parameters() {
                use #ruma_common::api::path_builder::PathBuilder as _;

                let path_params = <super::#ident as #ruma_common::api::Metadata>::PATH_BUILDER._path_parameters();
                let request_path_fields: &[&::std::primitive::str] = &[#(#path_fields),*];
                ::std::assert_eq!(
                    path_params, request_path_fields,
                    "Path parameters must match the `Request`'s `#[ruma_api(path)]` fields"
                );
            }
        }
    }

    /// Generate code for a comma-separated list of field names.
    ///
    /// No attributes are forwarded.
    fn expand_fields(&self) -> TokenStream {
        expand_fields_as_list(&self.0)
    }
}

/// Request query fields.
#[derive(Default)]
#[allow(clippy::large_enum_variant)]
enum RequestQuery {
    /// The request doesn't contain a query.
    #[default]
    None,

    /// The fields containing the query parameters.
    Fields(Vec<syn::Field>),

    /// The single field containing the whole query.
    All(syn::Field),
}

impl RequestQuery {
    /// Generate code to define a `struct RequestQuery` used for (de)serializing the query of
    /// request.
    fn expand_serde_struct_definition(
        &self,
        ruma_macros: &TokenStream,
        serde: &TokenStream,
    ) -> Option<TokenStream> {
        let (fields, extra_attrs) = match self {
            Self::None => return None,
            Self::Fields(fields) => (fields.as_slice(), None),
            Self::All(field) => {
                let extra_attrs = quote! { #[serde(transparent)] };
                (std::slice::from_ref(field), Some(extra_attrs))
            }
        };

        let fields = fields.iter().map(PrivateField);

        Some(quote! {
            /// Data in the request's query string.
            #[cfg(any(feature = "client", feature = "server"))]
            #[derive(Debug, #ruma_macros::_FakeDeriveRumaApi, #ruma_macros::_FakeDeriveSerde)]
            #[cfg_attr(feature = "client", derive(#serde::Serialize))]
            #[cfg_attr(feature = "server", derive(#serde::Deserialize))]
            #extra_attrs
            struct RequestQuery { #( #fields ),* }
        })
    }

    /// Generate code for a comma-separated list of field names.
    ///
    /// Only the `#[cfg]` attributes on the fields are forwarded.
    fn expand_fields(&self) -> Option<TokenStream> {
        let fields = match self {
            Self::None => return None,
            Self::Fields(fields) => fields.as_slice(),
            Self::All(field) => std::slice::from_ref(field),
        };

        Some(expand_fields_as_list(fields))
    }
}

/// Parsed request body fields.
#[derive(Default)]
enum RequestBody {
    /// The request has an empty body.
    ///
    /// An empty body might contain no data at all or an empty JSON object, depending on the
    /// expected content type of the request.
    #[default]
    Empty,

    /// The body is a JSON object containing the given fields.
    JsonFields(Vec<syn::Field>),

    /// The body is a JSON object represented by the given single field.
    JsonAll(syn::Field),

    /// The body contains raw data represented by the given single field.
    Raw(syn::Field),
}

impl RequestBody {
    /// The list of fields for the JSON data of the body.
    fn json_fields(&self) -> Option<&[syn::Field]> {
        let fields = match self {
            Self::Empty | Self::Raw(_) => return None,
            Self::JsonFields(fields) => fields.as_slice(),
            Self::JsonAll(field) => std::slice::from_ref(field),
        };

        Some(fields)
    }

    /// Generate code to define a `struct RequestBody` used for (de)serializing the JSON body of
    /// request.
    fn expand_serde_struct_definition(
        &self,
        ruma_macros: &TokenStream,
        serde: &TokenStream,
    ) -> Option<TokenStream> {
        let fields = self.json_fields()?.iter().map(PrivateField);

        let extra_attrs =
            matches!(self, Self::JsonAll(_)).then(|| quote! { #[serde(transparent)] });

        Some(quote! {
            /// Data in the request body.
            #[cfg(any(feature = "client", feature = "server"))]
            #[derive(Debug, #ruma_macros::_FakeDeriveRumaApi, #ruma_macros::_FakeDeriveSerde)]
            #[cfg_attr(feature = "client", derive(#serde::Serialize))]
            #[cfg_attr(feature = "server", derive(#serde::Deserialize))]
            #extra_attrs
            struct RequestBody { #( #fields ),* }
        })
    }

    /// Generate code to test the body for the request with given ident.
    fn expand_tests(&self, ident: &syn::Ident, ruma_common: &TokenStream) -> Option<TokenStream> {
        if !matches!(self, RequestBody::Empty) {
            let http = quote! { #ruma_common::exports::http };

            Some(quote! {
                #[::std::prelude::v1::test]
                fn request_is_not_get() {
                    ::std::assert_ne!(
                        <super::#ident as #ruma_common::api::Metadata>::METHOD, #http::Method::GET,
                        "GET endpoints can't have body fields",
                    );
                }
            })
        } else {
            None
        }
    }

    /// Generate code for a comma-separated list of field names.
    ///
    /// Only the `#[cfg]` attributes on the fields are forwarded.
    fn expand_fields(&self) -> Option<TokenStream> {
        let fields = match self {
            Self::Empty => return None,
            Self::JsonFields(fields) => fields.as_slice(),
            Self::JsonAll(field) => std::slice::from_ref(field),
            Self::Raw(field) => std::slice::from_ref(field),
        };

        Some(expand_fields_as_list(fields))
    }
}
