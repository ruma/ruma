//! Implementations and types to parse the `ruma_id` macro input.

use proc_macro2::Span;
use quote::quote;
use syn::meta::ParseNestedMeta;

use super::{RumaId, StorageCfg, Types};
use crate::util::RumaCommon;

impl RumaId {
    /// Parse the given `ruma_id` macro input.
    pub(super) fn parse(attrs: RumaIdAttrs, input: syn::ItemStruct) -> syn::Result<Self> {
        let RumaIdAttrs { validate } = attrs;

        if !input.fields.is_empty() {
            return Err(syn::Error::new(
                Span::call_site(),
                "Only structs without fields are supported, the inner representation is generated by the ruma_id macro",
            ));
        }

        if validate.is_none() && !input.generics.params.is_empty() {
            return Err(syn::Error::new(
                Span::call_site(),
                "IDs without validation and with generics are not supported",
            ));
        }

        if input.generics.where_clause.is_some() {
            // So we don't have to insert #where_clause everywhere when it is always None in
            // practice.
            return Err(syn::Error::new(
                Span::call_site(),
                "where clauses on IDs are not supported",
            ));
        }

        if let Some(param) =
            input.generics.params.iter().find(|param| !matches!(param, syn::GenericParam::Type(_)))
        {
            return Err(syn::Error::new_spanned(
                param,
                "Only generic type parameters are supported",
            ));
        }

        let generics = input.generics;
        let (impl_generics, type_generics, _where_clause) = generics.split_for_impl();
        let impl_generics = quote! { #impl_generics };

        let ident = input.ident;
        let types = Types::new(&ident, type_generics);

        Ok(Self {
            attrs: input.attrs,
            ident,
            generics,
            impl_generics,
            validate,
            types,
            storage_cfg: StorageCfg::new(),
            ruma_common: RumaCommon::new(),
        })
    }
}

/// The parsed attributes of the [`RumaId`].
#[derive(Default)]
pub(crate) struct RumaIdAttrs {
    /// The path to the function to use to validate the identifier.
    validate: Option<syn::Path>,
}

impl RumaIdAttrs {
    /// Set the path to the function to use to validate the identifier.
    ///
    /// Returns an error if it is already set.
    fn set_validate(&mut self, validate: syn::Path) -> syn::Result<()> {
        if self.validate.is_some() {
            return Err(syn::Error::new(
                Span::call_site(),
                "cannot have multiple values for `validate` attribute",
            ));
        }

        self.validate = Some(validate);
        Ok(())
    }

    /// Try to parse the given meta item and merge it into this `RumaIdAttrs`.
    ///
    /// Returns an error if an unknown `ruma_id` attribute is encountered, or if an attribute
    /// that accepts a single value appears several times.
    pub(crate) fn try_merge(&mut self, meta: ParseNestedMeta<'_>) -> syn::Result<()> {
        if meta.path.is_ident("validate") {
            return self.set_validate(meta.value()?.parse()?);
        }

        Err(meta.error("unsupported `ruma_id` attribute"))
    }
}
