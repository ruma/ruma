# ruma-events

[![crates.io page](https://img.shields.io/crates/v/ruma-events.svg)](https://crates.io/crates/ruma-events)
[![docs.rs page](https://docs.rs/ruma-events/badge.svg)](https://docs.rs/ruma-events/)
![license: MIT](https://img.shields.io/crates/l/ruma-events.svg)

**ruma-events** contains serializable types for the events in the [Matrix](https://matrix.org/) specification that can be shared by client and server code.

## Minimum Rust version

ruma-events requires Rust 1.40.0 or later.

## Documentation

ruma-events has [comprehensive documentation](https://docs.rs/ruma-events) available on docs.rs.

# How-To

## Deserializing

Ruma offers the `EventJson` wrapper to enable passing around JSON text that is semi validated. This
is useful when [extending ruma](TODO_link). All event structs and enums implement `Serialize/Deserialize` so
EventJson is not strictly needed anymore (pre 0.22 this was not the case).

```rust
let json = r#"{ "type": "imagine a full event", "content": {...} }"#;

let deser = serde_json::from_str::<EventJson<AnyRoomEvent>>()
    .unwrap() // the first Result from serde_json::from_str
    .deserialize() // this deserializes the event while still keeping the RawJson in EventJson
    .unwrap() // finally get to the AnyRoomEvent

// event content has a trait function that allows for validated deserialization
let content = r#"{ "membership": "imagine member event content", ... }"#;
let deser = EventContent::from_parts("m.room.member", serde_json::value::to_raw_value(content)).unwrap();
// There is also a method to convert the content to the redacted version according to the Matrix spec
// The only field left is `membership`
let redacted = deser.redact();
```

## Creating Events to Extend Ruma

For our example we will create a reaction message event. This can be used with ruma's event structs, for
this event we need a `MessageEventStub` struct but, either `MessageEvent` struct would work.

```rust
use ruma_events_macros::MessageEventContent;
use ruma_identifiers::EventId;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(tag = "rel_type")]
pub enum RelatesTo {
    #[serde(rename = "m.annotation")]
    Annotation {
        /// The event this reaction relates to.
        event_id: EventId,
        /// The displayable content of the reaction.
        key: String,
    },

    /// Since this event is not fully specified in the Matrix spec
    /// it may change or types may be added, we are ready!
    #[serde(rename = "m.whatever")]
    Whatever,
}

/// The payload for our reaction event.
#[derive(Clone, Debug, Deserialize, Serialize, MessageEventContent)]
#[ruma_event(type = "m.reaction")]
pub struct ReactionEventContent {
    #[serde(rename = "m.relates_to")]
    pub relates_to: RelatesTo,
}

fn test_reaction() {
    use crate::MessageEventStub;

    let json = serde_json::json!({
        "content": {
            "m.relates_to": {
                "event_id": "$xxxx-xxxx",
                "key": "üëç",
                "rel_type": "m.annotation"
            }
        },
        "event_id": "$xxxx-xxxx",
        "origin_server_ts": 1,
        "sender": "@someone:example.org",
        "type": "m.reaction",
        "unsigned": {
            "age": 85
        }
    });

    // The downside of the is that we can't use this with the `AnyRoomEvent[Stub]` or `AnyEvent[Stub]` enums,
    // but can try deserializing them when we get a custom event or a failed event deserialization.
    matches::assert_matches!(
        serde_json::from_value::<MessageEventStub<ReactionEventContent>>(json),
        Ok(MessageEventStub {
            content: ReactionEventContent {
                relates_to: RelatesTo::Annotation { key, .. },
            },
            ..
        }) if key == "üëç"
    );
}
```

## Structure

```rust
// src/enums.rs

// these are full events (with room_id)
enum AnyRoomEvent {
    Message(AnyMessageEvent),
    State(AnyStateEvent),
    RedactedMessage(AnyRedactedMessageEvent),
    RedactedState(AnyRedactedStateEvent),
}

// Stub events are going to be renamed to Sync eventually as they are
// the events that come from a sync response with no room_id field
enum AnyRoomEventStub {
    Message(AnyMessageEventStub),
    State(AnyStateEventStub),
    RedactedMessage(AnyRedactedMessageEventStub),
    RedactedState(AnyRedactedStateEventStub),
}

// These are generated by a macro and correspond to the old collections::all/only::RoomEvent enums
enum AnyStateEvent {
    RoomAliases(StateEvent<AliasesEventContent>),
    // ... the rest of the state events
}

enum AnyStateEventStub {
    RoomAliases(StateEventStub<AliasesEventContent>),
    // ... the rest of the state events
}

enum AnyStrippedStateEventStub {
    RoomAliases(StrippedStateEventStub<AliasesEventContent>),
    // ... the rest of the state events
}

// Now for the redacted events that are being added.
// There are also redacted stub and stripped versions of state events and
// full (with room_id) and stub version of message events. Message events
// are all EmptyRedactedMessageEvent since no content fields are kept.
enum AnyRedactedStateEvent {
    RoomAliases(EmptyRedactedStateEvent),
    RoomCreate(RedactedStateEvent<RedactedCreateEventContent>), // ... the rest of the state events
}

// TODO change the name
// There are endpoints that only send state events this enum wraps redacted and non-redacted
// events to allow sending the full range of events.
enum EitherStateEvent {
    Full(AnyStateEvent),
    Redacted(AnyRedactedStateEvent),
}

// src/event_kinds.rs

// The event structs, these follow the same patterns with different fields.
// There are full, stub, and stripped versions of state events, full and stub message events,
// full and stub ephemeral, basic event, to device event. Message and state have empty redacted
// versions of each event and state has full, stub, and stripped versions of generic redacted events.
struct StateEvent<C> {
    content: C,
    // ... fields for state event
}

struct RedactedStateEvent<C> {
    content: C,
    // ... fields for redacted state event
}

// So there are stripped and stub redacted state events and full and stub empty redacted
// message events also
struct EmptyRedactedStateEvent {
    // this is the "m.whatever"
    event_type: String,
    // ... fields for redacted state event no `content` field
}

// src/[room]/[name_of_event_content].rs

// The last piece is the content structs
struct CreateEventContent {
    // whatever fields are specified by the spec
    specific_content_fields: Foo,
}

// The few content structs that have any content after being redacted
struct RedactedCreateEventContent {
    // whatever fields are specified by the spec after redaction
    specific_content_fields: Foo,
}

// Otherwise a redacted event looks like this
struct RedactedMessageEventContent;
```
